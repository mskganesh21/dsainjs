/*
TREE DATA STRUCTURE

prerequisites 
recursion  oops concepts

every node is connected to 2 nodes
1 node has 2 pointers

why trees ?
o(log n)
ordered insertion and deletion
cost efficient

how to solve unbalanced binary tree ?
create self balancing binary tree

real world use cases
databases
file systems
algorithm / networking
maths
decision trees or ml
compression of files
future data structures graph
*/

/*
tree
each node has 2 childs

node : {
  value
  node left
  node right
}

size: total no of nodes

sublings: same parent

edge: 2 nodes connected by a line

height: max no of edges

leaf nodes: bottom nodes

level: 0 1 2 3 

ancestor and descendant

types of binary tree
complete binary tree
all levels are full apart from last level
last level should be full from left to right

full / strict binary tree
either 0 or 2 children
compression use case
segment tree

perfect binary tree
all levels are filled 


height balanced binary tree
AVL 
average height o(log n)


skewed binary tree
every node has only 1 child


ordered binary tree
every node has some property to follow
eg: binary search tree


properties:
perfect bt height = h
total nodes = 2 ^ (h+1) - 1
perfect bt has the max no of nodes
leaf nodes : 2^h
intermediary nodes: 2^h - 1
no of leaves = n
log n + 1 levels atleast

strict bt
total leaf nodes: n
internal nodes: n-1
no of leaf nodes : no of internal nodes + 1

degree: no of level  
*/

/*
implementation of binary trees
linked representation
sequential using array and define size

insert {
  insert left
  insert right
}

 
*/










